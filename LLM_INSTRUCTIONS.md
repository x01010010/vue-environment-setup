# AI/LLM Development Instructions for This Project

This document provides instructions for an AI/LLM assistant to build upon the foundation of this Vue.js project. Adhering to these guidelines is crucial for maintaining the project's architecture, quality, and consistency.

## 1. Project Overview

This is a Vue.js 3 project built with TypeScript, Vite, Vuetify for UI components, and Tailwind CSS for utility-first styling. It features a robust setup for professional development, including:

-   **Modular Setup Script**: The entire project is generated by a series of shell scripts in the `setup/` directory, orchestrated by `vue_setup.sh`.
-   **Structured API Layer**: A scalable API layer using Axios is located in `src/api`, with a base instance, interceptors, and typed services.
-   **Reactive Composables**: The `src/composables/useApi.ts` provides a reactive, reusable way to make API calls in Vue components.
-   **100% Unit Test Coverage**: A strict requirement for 100% test coverage is enforced using Vitest and Vue Test Utils.
-   **Linting and Formatting**: ESLint and Prettier are configured to maintain code quality.
-   **Git Hooks**: Husky is used to enforce linting and testing before commits.

## 2. Core Architectural Principles

-   **Modularity**: Functionality is broken down into small, single-responsibility modules. This applies to the setup scripts, the Vue components, and the API services.
-   **Test-Driven Development (TDD) Mentality**: Every new feature must be accompanied by comprehensive tests. The goal is always 100% coverage for the logic being added.
-   **Configuration as Code**: All tool configurations (Vite, Vitest, ESLint, TypeScript) are tracked in the repository.
-   **Separation of Concerns**: UI components (`src/components`, `src/views`), business logic/API calls (`src/api`, `src/composables`), and application setup (`main.ts`, `router/index.ts`) are kept separate.

## 3. How to Add a New Feature (e.g., A New View)

Follow these steps precisely when adding a new feature.

### Step 1: Create the Component/View File

-   Create the new `.vue` file in the appropriate directory (`src/views` for a page, `src/components` for a reusable component).
-   Use Vuetify components and Tailwind CSS classes for the UI.
-   Use the `<script setup lang="ts">` syntax.
-   If the component needs to fetch data, import and use the `useApi` composable.

**Example**:
```vue
<!-- src/views/NewFeatureView.vue -->
<template>
  <v-container>
    <v-card>
      <v-card-title>New Feature</v-card-title>
      <v-card-text>
        <div v-if="isLoading">Loading...</div>
        <div v-if="error">{{ error.message }}</div>
        <pre v-if="data">{{ data }}</pre>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup lang="ts">
import { useApi } from '@/composables/useApi';
import { exampleService } from '@/api/services/exampleService';

const { data, isLoading, error } = useApi(exampleService.getExamples);
</script>
```

### Step 2: Add a Route

-   If you created a new view, add a route for it in `src/router/index.ts`.
-   Use lazy loading for the component import.

**Example**:
```typescript
// src/router/index.ts
// ... existing code ...
    {
      path: '/new-feature',
      name: 'new-feature',
      component: () => import('../views/NewFeatureView.vue')
    }
// ... existing code ...
```

### Step 3: Write the Unit Test

-   Create a new test file in `src/test/` (e.g., `NewFeatureView.spec.ts`).
-   Your test **must** cover all logic and rendering paths in your new component.
-   **Crucially, you must mock all API calls.** Use `vi.mock` to mock the API service module.

**Example**:
```typescript
// src/test/NewFeatureView.spec.ts
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import NewFeatureView from '@/views/NewFeatureView.vue';
import { nextTick } from 'vue';

// Mock the entire service module
vi.mock('@/api/services/exampleService', () => ({
  exampleService: {
    getExamples: vi.fn(),
  },
}));

// We need to import the mocked service *after* the mock is set up
const { exampleService } = await import('@/api/services/exampleService');

describe('NewFeatureView.vue', () => {
  it('displays loading state initially', () => {
    // Set the mock to return a promise that never resolves
    (exampleService.getExamples as vi.Mock).mockReturnValue(new Promise(() => {}));
    const wrapper = mount(NewFeatureView);
    expect(wrapper.text()).toContain('Loading...');
  });

  it('displays data when the API call succeeds', async () => {
    const mockData = [{ id: 1, name: 'Test' }];
    // Set the mock to return resolved data
    (exampleService.getExamples as vi.Mock).mockResolvedValue({ data: mockData });
    const wrapper = mount(NewFeatureView);
    
    // Wait for the promise to resolve and Vue to re-render
    await nextTick();
    await nextTick();

    expect(wrapper.text()).not.toContain('Loading...');
    expect(wrapper.find('pre').text()).toContain(JSON.stringify(mockData));
  });
  
  it('displays an error message when the API call fails', async () => {
    const mockError = new Error('API Failure');
    (exampleService.getExamples as vi.Mock).mockRejectedValue(mockError);
    const wrapper = mount(NewFeatureView);
    
    await nextTick();
    await nextTick();
    
    expect(wrapper.text()).not.toContain('Loading...');
    expect(wrapper.text()).toContain(mockError.message);
  });
});
```

### Step 4: Verify 100% Coverage

-   Run `npm test -- --coverage`.
-   Analyze the report in `coverage/index.html`.
-   If your new files are not at 100%, add more tests until they are.
-   Do not lower the coverage thresholds in `vitest.config.ts`.

## 4. How to Update Dependencies

-   Use `npm outdated` to check for new package versions.
-   Use `npm install <package-name>@latest` to update a specific package.
-   After updating, run the full test suite (`npm test`) to ensure no breaking changes were introduced.
-   Update the corresponding version numbers in the `setup/dependencies.sh` script to ensure new projects are created with the latest versions.

By following these instructions, you will be able to contribute to this project effectively while upholding its quality standards. 